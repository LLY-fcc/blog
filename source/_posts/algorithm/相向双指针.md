## O(1) 的时间获取O(n)的信息
遍历有序数组时，对于任一个元素，在其之前的元素均小于等于它，反之大于等于它

### 两数之和
>题目：[167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)
>题解：[两数之和 三数之和【基础算法精讲 01】](https://www.bilibili.com/video/BV1bP411c7oJ/)
>简介：给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列**  ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。
>
>以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。
>
>你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。
>
>你所设计的解决方案必须只使用常量级的额外空间。


```ts
function twoSum(numbers: number[], target: number): number[] {
	// 记录数组长度，便于引用以计算索引
	const n = numbers.length
	
	// 初始化左右指针
	let i = 0, j = n -1
	
	while (i < j) {
		const s = nums[i] + nums[j]
		
		if (s === target) {
			break
		}
		
		if (s < target) {
			// 因为数组有序，为了逼近 target，只能尝试将
			// 指向“较小”一侧的指针向“较大”的方向移动
			i++
		} else {
			// 参考上，相反的逻辑
			j--
		}
	}
	
	// 题目要求返回从 1 开始的数组下标对
	return [i + 1, j + 1]
};
```

### 三数之和
>题目：[15. 三数之和](https://leetcode.cn/problems/3sum/)
>题解：[两数之和 三数之和【基础算法精讲 01】](https://www.bilibili.com/video/BV1bP411c7oJ/)
>简介：给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。


```ts
function threeSum(nums: number[]): number[][] {
	const n = nums.length
	const ans = []
	
	// 三数之和可以看作 遍历 + 两数之和
	// 为了利用两数之和的双指针，先排序
	// js 的排序函数默认按照字典顺序排序，所以必须手动配置排序规则
	nums.sort((a, b) => a - b)
	for (let i = 0;i < n - 2;i++) {
		const x = nums[i]
		
		// 剪掉相同值的【被加数】
		if (i > 0 && x === nums[i - 1]) {
			continue
		}
		
		// 如果最小的三个数相加都比目标值大，且数组有序，
		// 则后面所有组合相加都比目标值大，没有继续的意义
		if (x + nums[i + 1] + nums[i + 2] > target) {
			break
		}
		
		// 为什么不将最大的三个数相加的结果和目标值进行比较呢？
		// 每次看到这里请思考
		
		// 如果【被加数】和剩余的【加数】中最大的两个相加都
		// 小于目标值，则认为后续的双指针没有意义
		if (x + nums[n - 2] + nums[n - 1] < target) {
			continue
		}
		
		// 初始化指针
		let j = i + 1,k = n - 1
		while (j < k) {
			const s = x + nums[j] + nums[k]
			if (s > 0) {
				k--
			} else if (s < 0) {
				j++
			} else {
				ans.push([x, nums[j], nums[k]])
				// 与【双数之和】近求解单个解不同，这里要求全部解
				// 所以需要尽可能遍历所有结果
				
				// j++
				// k--
				
				// 为了【剪枝】，避免不必要的循环，对于相等的【加数】
				// 其再次相加必然导致重复的结果，剪掉
				for(j++;j<k && nums[j] === nums[j-1];j++) {}
				for(k--;k>j && nums[k] === nums[k+1];k--) {}
			}
		}
	}
	
	return ans
}
```

### 小于目标两数和
>题目：[2824. 统计和小于目标的下标对数目](https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/)
>题解：[O(nlogn) 排序+相向双指针（Python/Java/C++/C/Go/JS/Rust）]([https://www.bilibili.com/video/BV1bP411c7oJ/](https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/solutions/2396216/onlogn-pai-xu-shuang-zhi-zhen-by-endless-qk40/))
>简介：给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` 和一个整数 `target` ，请你返回满足 `0 <= i < j < n` 且 `nums[i] + nums[j] < target` 的下标对 `(i, j)` 的数目。

### 最接近目标三数和
>题目：[16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)
>题解：[极致优化！基于三数之和的做法（Python/Java/C++/C/Go/JS/Rust）](https://leetcode.cn/problems/3sum-closest/solutions/2337801/ji-zhi-you-hua-ji-yu-san-shu-zhi-he-de-z-qgqi/)
>简介：给你一个长度为 `n` 的整数数组 `nums` 和 一个目标值 `target`。请你从 `nums` 中选出三个在 **不同下标位置** 的整数，使它们的和与 `target` 最接近。
>
>返回这三个数的和。
>
>假定每组输入只存在恰好一个解。

### 四数之和
>题目：[18. 四数之和](https://leetcode.cn/problems/4sum/)
>题解：[极致优化！基于三数之和的做法（Python/Java/C++/Go/JS/Rust）](https://leetcode.cn/problems/4sum/solutions/2344514/ji-zhi-you-hua-ji-yu-san-shu-zhi-he-de-z-1f0b/)
>简介：给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：
>
>- `0 <= a, b, c, d < n`
>- `a`、`b`、`c` 和 `d` **互不相同**
>- `nums[a] + nums[b] + nums[c] + nums[d] == target`
>
>你可以按 **任意顺序** 返回答案 。
